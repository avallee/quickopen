#!/usr/bin/python2.6
# Copyright 2011 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging
import optparse
import os
import platform
import re
import sys

import src.settings
import src.db_proxy

###########################################################################

def CMDadd(parser, args):
  """Adds a directory to the index"""
  (options, args) = parser.parse_args(args)
  settings = load_settings(options)
  db = open_db(settings, options)
  if len(args) == 0:
    parser.error('Expected at least one directory')
  for d in args:
    db.add_dir(d)
  return 0

def CMDdirs(parser, args):
  """Lists currently-indexed directories"""
  (options, args) = parser.parse_args(args)
  settings = load_settings(options)
  db = open_db(settings, options)
  if len(args):
    parser.error('Unrecognized args: %s' % ' '.join(args))
  print "\n".join([x.path for x in db.dirs])
  return 0

def CMDrmdir(parser, args):
  """Removes a currently-indexed directory"""
  (options, args) = parser.parse_args(args)
  settings = load_settings(options)
  db = open_db(settings, options)
  dmap = {}
  for d in db.dirs:
    dmap[d.path] = d
  ok = True
  for d in args:
    if d not in dmap:
      ok = False
      print "%s not found" % d
    else:
      db.delete_dir(dmap[d])
      print "%s removed" % d
  if ok:
    return 0
  return 255

def CMDsearch(parser, args):
  """Search for a file"""
  parser.add_option('--ok', dest='ok', action='store_true', default=False, help='Output "OK" before results')
  (options, args) = parser.parse_args(args)
  settings = load_settings(options)
  db = open_db(settings, options)

  def run():
    # try using gtk
    has_gtk = False
    try:
      import pygtk
      pygtk.require('2.0')
      has_gtk = True
    except ImportError:
      pass

    if has_gtk:
      import src.open_dialog_gtk
      return src.open_dialog_gtk.run(settings, db)

    # if that didn't work, try using wx
    has_wx = False
    try:
      import wx
      has_wx = True
    except ImportError:
      pass

    if has_wx:
      import src.open_dialog_wx
      return src.open_dialog_wx.run(settings, db)

    raise ImportError()
  
  try:
    res = run()
  except ImportError:
    print "pygtk nor WxPython found. Please install one and try again.\n"
    return 255

  if res:
    if options.ok:
      print "OK"
    print "\n".join(res)
    return 0

def CMDstatus(parser, args):
  """Checks the status of the quick open database"""
  (options, args) = parser.parse_args(args)
  settings = load_settings(options)
  db = open_db(settings, options)
  print db.status().status

def CMDrawsearch(parser, args):
  """Prints the raw database's results for <query>"""
  parser.add_option('--show-rank', '-r', dest='show_rank', action='store_true', help='Show the ranking of results')
  (options, args) = parser.parse_args(args)

  settings = load_settings(options)
  db = open_db(settings, options)
  if len(args) != 1:
    parser.error('Expected: <query>')
  if not db.has_index:
    print "Database is not fully indexed. Wait a bit or try quickopen status"
    return 255
  res = db.search(args[0])
  if options.show_rank:
    combined = [(res.ranks[i],res.hits[i]) for i in range(len(res.hits))]
    print "\n".join(["%i,%s" % c for c in combined])
  else:
    print "\n".join([x for x in res.hits])

  if len(res.hits) > 0:
    return 0
  return 255

def load_settings(options):
  settings_file = os.path.expanduser(options.settings)
  settings = src.settings.Settings(settings_file)
  settings.register('host', str, 'localhost')
  settings.register('port', int, 10248)
  return settings

def open_db(settings,options):
  if not options.host:
    options.host = settings.host
  if not options.port:
    options.port = settings.port

  # Open the quickopend settings file to get the default
  # port for the daemon.
  daemon_settings_file = os.path.expanduser("~/.quickopend")
  settings = src.settings.Settings(daemon_settings_file)
  settings.register('port', int, 10248) # keep in sync with quickopend default

  db = src.db_proxy.DBProxy(options.host, options.port, start_if_needed=True, port_for_autostart=settings.port)
  return db

# Subcommand addins to optparse, taken from git-cl.py, 
# http://src.chromium.org/svn/trunk/tools/depot_tools/git_cl.py
###########################################################################

def Command(name):
  return getattr(sys.modules[__name__], 'CMD' + name, None)


def CMDhelp(parser, args):
  """print list of commands or help for a specific command"""
  _, args = parser.parse_args(args)
  if len(args) == 1:
    return main(args + ['--help'])
  parser.print_help()
  return 0


def GenUsage(parser, command):
  """Modify an OptParse object with the function's documentation."""
  obj = Command(command)
  more = getattr(obj, 'usage_more', '')
  if command == 'help':
    command = '<command>'
  else:
    # OptParser.description prefer nicely non-formatted strings.
    parser.description = re.sub('[\r\n ]{2,}', ' ', obj.__doc__)
  parser.set_usage('usage: %%prog %s [options] %s' % (command, more))


def main(argv):
  """Doesn't parse the arguments here, just find the right subcommand to
  execute."""
  # Do it late so all commands are listed.
  CMDhelp.usage_more = ('\n\nCommands are:\n' + '\n'.join([
      '  %-10s %s' % (fn[3:], Command(fn[3:]).__doc__.split('\n')[0].strip())
      for fn in dir(sys.modules[__name__]) if fn.startswith('CMD')]))

  # Create the option parse and add --verbose support.
  parser = optparse.OptionParser()
  parser.add_option(
      '-v', '--verbose', action='count', default=0,
      help='Increase verbosity level (repeat as needed)')
  parser.add_option('--host', dest='host', action='store', help='Hostname of quickopend server')
  parser.add_option('--port', dest='port', action='store', help='Port for quickopend')
  parser.add_option('--settings', dest='settings', action='store', default='~/.quickopen', help='Settings file to use, ~/.quickopen by default')
  old_parser_args = parser.parse_args
  def Parse(args):
    options, args = old_parser_args(args)
    if options.verbose >= 2:
      logging.basicConfig(level=logging.DEBUG)
    elif options.verbose:
      logging.basicConfig(level=logging.INFO)
    else:
      logging.basicConfig(level=logging.WARNING)
    return options, args
  parser.parse_args = Parse

  if argv:
    command = Command(argv[0])
    if command:
      # "fix" the usage and the description now that we know the subcommand.
      GenUsage(parser, argv[0])
      return command(parser, argv[1:])
    # Not a known command. Default to help.
    GenUsage(parser, 'help')
    return CMDhelp(parser, argv)
  else: # default command
    GenUsage(parser, 'search')
    return CMDsearch(parser, argv)

if __name__ == '__main__':
  if platform.system() == 'Darwin':
    wx_found_but_failed = False
    try:
      import wx
    except ImportError:
      if str(sys.exc_value).find("no appropriate 64-bit"):
        wx_found_but_failed = True

    # To use wx-widgets on darwin, we need to be in 32 bit mode :'(
    if wx_found_but_failed:
      # try using the versioner trick
      if '--triedenv' not in sys.argv:
        os.putenv('VERSIONER_PYTHON_PREFER_32_BIT', 'yes')
        args = [sys.executable, sys.argv[0], '--triedenv']
        args.extend(sys.argv[1:])
        os.execve(args[0], args, os.environ)

      # last chance...
      if '--triedarch' not in sys.argv:
        args = ["/usr/bin/arch", "-i386", sys.executable, sys.argv[0], '--triedarch']
        args.extend(sys.argv[1:])
        os.execv(args[0], args)

      # did we already try one of the tricks below? Bail out to prevent recursion...
      print "Your system's python is 64 bit, and all the tricks we know to get it into 32b mode failed."
      sys.exit(255)

    else:
      try:
        sys.argv.remove('--triedenv')
      except:
        pass
      try:
        sys.argv.remove('--triedarch')
      except:
        pass
      sys.exit(main(sys.argv[1:]))

  else:
    sys.exit(main(sys.argv[1:]))
